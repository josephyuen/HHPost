package org.libjpegturbo.turbojpeg

/**
 * Creator: 李佳胜
 * FuncDesc:
 * copyright  ©2018-2020 艾戴特 Corporation. All rights reserved.
 */
object TJ {

    /**
     * 4:4:4 chrominance subsampling (no chrominance subsampling).  The JPEG
     * or YUV image will contain one chrominance component for every pixel in the
     * source image.
     */
    val SAMP_444 = 0
    /**
     * 4:2:2 chrominance subsampling.  The JPEG or YUV image will contain one
     * chrominance component for every 2x1 block of pixels in the source image.
     */
    val SAMP_422 = 1
    /**
     * 4:2:0 chrominance subsampling.  The JPEG or YUV image will contain one
     * chrominance component for every 2x2 block of pixels in the source image.
     */
    val SAMP_420 = 2
    /**
     * Grayscale.  The JPEG or YUV image will contain no chrominance components.
     */
    val SAMP_GRAY = 3
    /**
     * 4:4:0 chrominance subsampling.  The JPEG or YUV image will contain one
     * chrominance component for every 1x2 block of pixels in the source image.
     * Note that 4:4:0 subsampling is not fully accelerated in libjpeg-turbo.
     */
    val SAMP_440 = 4
    /**
     * 4:1:1 chrominance subsampling.  The JPEG or YUV image will contain one
     * chrominance component for every 4x1 block of pixels in the source image.
     * JPEG images compressed with 4:1:1 subsampling will be almost exactly the
     * same size as those compressed with 4:2:0 subsampling, and in the
     * aggregate, both subsampling methods produce approximately the same
     * perceptual quality.  However, 4:1:1 is better able to reproduce sharp
     * horizontal features.  Note that 4:1:1 subsampling is not fully accelerated
     * in libjpeg-turbo.
     */
    val SAMP_411 = 5


    /**
     * The uncompressed source/destination image is stored in bottom-up (Windows,
     * OpenGL) order, not top-down (X11) order.
     */
    val FLAG_BOTTOMUP = 2

    @Deprecated("")
    val FLAG_FORCEMMX = 8
    @Deprecated("")
    val FLAG_FORCESSE = 16
    @Deprecated("")
    val FLAG_FORCESSE2 = 32
    @Deprecated("")
    val FLAG_FORCESSE3 = 128

    /**
     * When decompressing an image that was compressed using chrominance
     * subsampling, use the fastest chrominance upsampling algorithm available in
     * the underlying codec.  The default is to use smooth upsampling, which
     * creates a smooth transition between neighboring chrominance components in
     * order to reduce upsampling artifacts in the decompressed image.
     */
    val FLAG_FASTUPSAMPLE = 256
    /**
     * Use the fastest DCT/IDCT algorithm available in the underlying codec.  The
     * default if this flag is not specified is implementation-specific.  For
     * example, the implementation of TurboJPEG for libjpeg[-turbo] uses the fast
     * algorithm by default when compressing, because this has been shown to have
     * only a very slight effect on accuracy, but it uses the accurate algorithm
     * when decompressing, because this has been shown to have a larger effect.
     */
    val FLAG_FASTDCT = 2048
    /**
     * Use the most accurate DCT/IDCT algorithm available in the underlying
     * codec.  The default if this flag is not specified is
     * implementation-specific.  For example, the implementation of TurboJPEG for
     * libjpeg[-turbo] uses the fast algorithm by default when compressing,
     * because this has been shown to have only a very slight effect on accuracy,
     * but it uses the accurate algorithm when decompressing, because this has
     * been shown to have a larger effect.
     */
    val FLAG_ACCURATEDCT = 4096
    /**
     * Immediately discontinue the current compression/decompression/transform
     * operation if the underlying codec throws a warning (non-fatal error).  The
     * default behavior is to allow the operation to complete unless a fatal
     * error is encountered.
     *
     *
     * NOTE: due to the design of the TurboJPEG Java API, only certain methods
     * with a void return type) will complete and leave the output image in a
     * fully recoverable state after a non-fatal error occurs.
     */
    val FLAG_STOPONWARNING = 8192
    /**
     * Use progressive entropy coding in JPEG images generated by compression and
     * transform operations.  Progressive entropy coding will generally improve
     * compression relative to baseline entropy coding (the default), but it will
     * reduce compression and decompression performance considerably.
     */
    val FLAG_PROGRESSIVE = 16384


    val PF_RGB = 0
    /**
     * BGR pixel format.  The red, green, and blue components in the image are
     * stored in 3-byte pixels in the order B, G, R from lowest to highest byte
     * address within each pixel.
     */
    val PF_BGR = 1
    /**
     * RGBX pixel format.  The red, green, and blue components in the image are
     * stored in 4-byte pixels in the order R, G, B from lowest to highest byte
     * address within each pixel.  The X component is ignored when compressing
     * and undefined when decompressing.
     */
    val PF_RGBX = 2
    /**
     * BGRX pixel format.  The red, green, and blue components in the image are
     * stored in 4-byte pixels in the order B, G, R from lowest to highest byte
     * address within each pixel.  The X component is ignored when compressing
     * and undefined when decompressing.
     */
    val PF_BGRX = 3
    /**
     * XBGR pixel format.  The red, green, and blue components in the image are
     * stored in 4-byte pixels in the order R, G, B from highest to lowest byte
     * address within each pixel.  The X component is ignored when compressing
     * and undefined when decompressing.
     */
    val PF_XBGR = 4
    /**
     * XRGB pixel format.  The red, green, and blue components in the image are
     * stored in 4-byte pixels in the order B, G, R from highest to lowest byte
     * address within each pixel.  The X component is ignored when compressing
     * and undefined when decompressing.
     */
    val PF_XRGB = 5
    /**
     * Grayscale pixel format.  Each 1-byte pixel represents a luminance
     * (brightness) level from 0 to 255.
     */
    val PF_GRAY = 6
    /**
     * RGBA pixel format.  This is the same as [.PF_RGBX], except that when
     * decompressing, the X byte is guaranteed to be 0xFF, which can be
     * interpreted as an opaque alpha channel.
     */
    val PF_RGBA = 7
    /**
     * BGRA pixel format.  This is the same as [.PF_BGRX], except that when
     * decompressing, the X byte is guaranteed to be 0xFF, which can be
     * interpreted as an opaque alpha channel.
     */
    val PF_BGRA = 8
    /**
     * ABGR pixel format.  This is the same as [.PF_XBGR], except that when
     * decompressing, the X byte is guaranteed to be 0xFF, which can be
     * interpreted as an opaque alpha channel.
     */
    val PF_ABGR = 9
    /**
     * ARGB pixel format.  This is the same as [.PF_XRGB], except that when
     * decompressing, the X byte is guaranteed to be 0xFF, which can be
     * interpreted as an opaque alpha channel.
     */
    val PF_ARGB = 10
    /**
     * CMYK pixel format.  Unlike RGB, which is an additive color model used
     * primarily for display, CMYK (Cyan/Magenta/Yellow/Key) is a subtractive
     * color model used primarily for printing.  In the CMYK color model, the
     * value of each color component typically corresponds to an amount of cyan,
     * magenta, yellow, or black ink that is applied to a white background.  In
     * order to convert between CMYK and RGB, it is necessary to use a color
     * management system (CMS.)  A CMS will attempt to map colors within the
     * printer's gamut to perceptually similar colors in the display's gamut and
     * vice versa, but the mapping is typically not 1:1 or reversible, nor can it
     * be defined with a simple formula.  Thus, such a conversion is out of scope
     * for a codec library.  However, the TurboJPEG API allows for compressing
     * CMYK pixels into a YCCK JPEG image and
     * decompressing YCCK JPEG images into CMYK pixels.
     */
    val PF_CMYK = 11

    private val PIXEL_SIZE = intArrayOf(3, 3, 4, 4, 4, 4, 1, 4, 4, 4, 4, 4)

    private val NUMSAMP = 6
    internal val NUMPF = 12


    fun getPixelSize(pixelFormat: Int): Int {
        checkPixelFormat(pixelFormat)
        return PIXEL_SIZE[pixelFormat]
    }

    private fun checkPixelFormat(pixelFormat: Int) {
        if (pixelFormat < 0 || pixelFormat >= NUMPF)
            throw IllegalArgumentException("Invalid pixel format")
    }

    private fun checkSubsampling(subsamp: Int) {
        if (subsamp < 0 || subsamp >= NUMSAMP)
            throw IllegalArgumentException("Invalid subsampling type")
    }

    external fun bufSize(width: Int, height: Int, jpegSubsamp: Int): Int

}
